---
title: 'Reglas Asociacion #2'
author: "José Antonio González Doñas"
date: "4/19/2018"
output: html_document
---

#* TODO: meter estilos css (centrar imagenes, cambiar color de fondo a los outputs, y fuente 'consolas', por ejemplo)

Vamos a realizar, uno a uno, todos los pasos descritos en el propio fichero del enunciado.

> ## 1. Descargar a local el dataset online.csv (en repositorio de GitHub ClassRoom - directorio datasets).

Para hacer uso de un dataset, hay dos opciones: 

1. importarlo mediante la interfaz gráfica de RStudio:

![Opción a elegir.](./imagenes/Screen Shot 2018-04-19 at 14.55.41.png)

![Resultado tras importar.](./imagenes/Screen Shot 2018-04-19 at 15.12.45.png)

2. mediante la instrucción read_csv()

```{r}
library(readr)
online <- read_csv("datasets/online.csv", col_names = FALSE)
```
Nótese que hay que especificar que la primera fila no se corresponde con el nombre de las columnas, de lo contrario se perderá información de esa primera fila. Para ello, se deselecciona la opción "First row as names".

> ## 2. Analizar la estructura, tipo,… del dataset.

Para analizar la estructura de un dataset existen varias funciones, entre las cuales, las más típicas y usadas son

* class()
* mode()
* str()

El método **class()** nos devuelve una lista de las clases de las cuales hereda el objeto pasado como argumento. En este caso, como podemos comprobar, **online** hereda de las clases **tbl_df** (table dataframe), **tbl** (table) y **data.frame**(data frame)

```{r}
class(online)
```


La función **mode()**, por otro lado, nos informa del 'modo de almacenamiento' del objeto, que en este caso resulta ser de tipo **list**
```{r}
mode(online)
```


En último lugar, **str** nos muestra la **estructura** del objeto. Esta función acepta una gran variedad de argumentos, pero si la usamos pasándole únicamente el objeto cuya estructura queremos analizar, obtenemos como resultado:

* las clases de las que hereda, al igual que hace la función **class()**
* una muestra de los valores que podemos encontrar en cada uno de sus columnas, campos, o subestructuras, dependiendo del tipo de objeto con el que estemos trabajando.
* un pequeño "sumario", similar a lo que nos devuelve la función **summary()**, que veremos más adelante, pero con mucho menos detalle.

Es una función muy útil para visualizar estructuras de datos que contienen listas anidadas, aunque como gran parte de las funciones de R, puede ser usada con objetos de cualquier clase.

```{r}
str(online)
```

En est caso, observamos, como ya mencionamos antes, que **online** es un objeto que hereda de **tbl_df**,**tbl** y **data.frame**, que contiene 22343 registros de 3 variables cada uno, y que la primera columna contiene valores de tipo fecha, la segunda de tipo entero, y la tercera de tipo caracter, entre otra información.

y **las cuales son muy recomendables usar cuando empezamos a trabajar con un conjunto de datos nuevos**, ya que nos van a dar muchas pistas de qué tenemos entre manos y nos ayudará a sacar mejor provecho y de forma más rápida toda la información que contiene.

> ## 3. Analizar significado, estructura, tipo,… de cada columna.

Ya hemos comprobado previamente, gracias a la función **str**, el tipo de cada columna. De todas formas, podemos comprobarlo una a una:

```{r}
class(online$X1)
class(online$X2)
class(online$X3)
```
**class()** nos indica que la primera columna tiene fechas, la segunda valores enteros y la tercera, cadena de caracteres.
Lo mismo podemos hace con el "modo" y su estructura:

```{r}
mode(online$X1)
mode(online$X2)
mode(online$X3)
```

La función modo nos indica por su parte que la información almacenada por las tres columnas es de tipo numérico para las dos primeras, y de caracteres para la tercera, lo cual es lógico: la fecha no deja de ser una información que hace uso de las operaciones numéricas para su tratamiento, más allá de cómo se represente. Las otras dos columnas son de tipo básicos, de ahí que se almacenen directamente como números y caracteres, respectivamente.

Finalmente, con respecto a sus estructuras:

```{r}
str(online$X1)
str(online$X2)
str(online$X3)
```

podemos decir a raíz de la información obtenida que:

* las fechas se almacenan con formato **aaaa-mm-dd**
* los números de la segunda columna, se almacenan simplemente con su valor numérico correspondiente
* los valores de la tercera columna se almacenan mediante la cadena de caracteres correspondiente.  

En resumen, está claro que en el dataset con el que vamos a trabajar, la información contenida es un conjunto de 22343 registros, donde en cada uno se muestra una fecha, una cantidad, y una etiqueta correspondiente a algo que aún no sabemos lo que es, pero que se aclarará en apartados siguientes y en cualquier caso, podemos inferir, ya que vemos que son nombres de productos de supermercado. En definitiva, podemos deducir que se trata de una base de datos de productos comprados por usuarios identificados por un número, en fechas concretas.

> ## 4. Comandos para ver las primeras filas y las últimas.

Para ver las primera y últimas filas de una estructura de datos en R, es tan fácil como usar las funciones **head()** y **tail()**, que nos muestran respectivamente, las seis primeras y seis últimas filas de dicha estructura:

```{r}
head(online)
tail(online)
```


> ## 5. Cambiar los nombres de las columnas: Fecha, IDcomprador,ProductoComprado.

Como el dataset original no contiene una fila donde se indique los nombres de columnas, vamos a cambiarlos por unos nombres que sean significativos y ayuden a entender mejor a cualquier persona que los use en adelante a entender qué datos tenemos entre mano.

En primer lugar, nos cercioramos de que no tienen nombre de columnas, o simplemente, vemos qué nombres tienen actualmente, en el caso de que deseemos cambiarlos por otros más adecuados. Para ello usamos la función **colnames()**:
 
```{r}
colnames(online)
```
 
 Una forma de cambiarlos muy simple, es asignar a la propiedad **colnames** del dataset **online** los valores que deseamos de forma directa mediante la asignación tradicional en R, es decir, usando el operador **<-**. Así pues, como sabemos que el conjunto de nombres de columnas no es más que un vector de tres elementos, entonces, si ejecutamos:
 
```{r}
colnames(online) <- c("Fecha","IDcomprador","ProductoComprado")
colnames(online)
```
 Podemos ver como efectivamente, estos valores han sido modificados en la estructura.
 
 Aparte de haciendo una nueva llamada a la función colnames(), podemos cerciorarnos volviendo a ejecutar head(), ya que a parte de las 6 primeras filas, muestra el nombre de las columnas:
 
```{r}
head(online)
```
 
 
> ## 6. Hacer un resumen (summary) del dataset y analizar toda la información detalladamente que devuelve el comando.
> ## 7. Implementar una función que usando funciones vectoriales de R (apply, tapply, sapply,…) te devuelva un primer valor booleana para saber si hay valores NA en alguna columna del dataset. Si así lo fuera devolver sus índices y además sustituirlos por el valor 0.
> ## 8. Calcular el número de filas del dataset.
> ## 9. Calcula en cuántas fechas distintas se han realizado ventas.
> ## 10. Calcula cuántos compradores distintos hay en el dataset.
> ## 11. Calcula cuántos producto distintos se han vendido.
> ## 12. Visualiza con distintos gráficos el dataset.

* Los valores distintos de cada columna con varios tipos de gráficos.
* Enfrenta unas variables contra otras para buscar patrones y comenta los patrones que puedas detectar.

> ## 13. Usa split para construir a partir del dataset una lista con nombre lista.compra.usuarios en la que cada elemento de la lista es cada comprador junto con todos los productos que ha comprado (de forma similar a lo visto en clase en el recomendador).
> ## 14. Hacer summary de lista.compra.usuarios.
> ## 15. Contar cuántos usuarios hay en la lista lista.compra.usuarios.
> ## 16. Detectar y eliminar duplicados en la lista.compra.usuarios (AYUDA: Usar lapply llamando a función unique).
> ## 17. Contar cuántos usuarios hay en la lista después de eliminar duplicados.
> ## 18. Convertir a tipo de datos transacciones. Guardar en Tlista.compra.usuarios.
> ## 19. Hacer inspect de los dos primeros valores de Tlista.compra.usuarios.
> ## 20. Buscar ayuda de itemFrequencyPlot para visualizar las 20 transacciones más frecuentes.
> ## 21. Generar las reglas de asociación con 80% de confianza y 15% de soporte.
> ## 22. Ver las reglas generadas y ordenalas por lift. Guarda el resultado en una variable nueva.
> ## 23. Elimina todas las reglas redundantes de las dos formas vistas en clase. Calcula el % de reglas redundantes que había usando cada uno de los dos métodos.
> ## 24. Dibuja las reglas ordenadas y no redundantes usando paquete arulesViz. Si son muchas visualiza las 20 primeras.
> ## 25. MUY IMPORTANTE: Investigar algún otro paquete R relacionado con reglas de asociación (no visto en clase). Explicar su uso con un dataset y con ejemplos.
